# Standard API Response Patterns

Moon enables rapid, migrationless management of database tables and records through a dynamic RESTful API.

## Table of Contents

- [Introduction](#introduction)
- [Standard Response Pattern](#standard-response-pattern)
  - [:list Endpoints](#list-endpoints)
  - [:get Endpoints](#get-endpoints)
  - [:create Endpoints](#create-endpoints)
  - [:destroy Endpoints](#destroy-endpoints)
  - [:update Endpoints](#update-endpoints)
  - [:schema Endpoints](#schema-endpoints)
- [Standard Error Response](#standard-error-response)
- [Public Endpoints](#public-endpoints)
- [Authentication](#authentication)
- [Manage User (Admin Only)](#manage-user-admin-only)
- [Manage API Keys (Admin Only)](#manage-api-keys-admin-only)
- [Manage Collections](#manage-collections)
- [Data Access](#data-access)
  - [Query Options](#query-options)
  - [Aggregation Operations](#aggregation-operations)
- [Security](#security)

## Introduction

This document describes the standard response patterns, query options, and aggregation operations for the Moon API. All endpoints follow consistent conventions for success and error responses.

### Moon Terminology

Moon stores data in the format: Collection, Field, and Record.

In database terminology, these are Tables, Columns, and Rows, respectively.

For example, consider the table `products` below.

```md
| id      | name           | price | in_stock |
| ------- | -------------- | ----- | -------- |
| 01H1... | Wireless Mouse | 29.99 | true     |
| 01H2... | USB Keyboard   | 19.99 | false    |
```

- **Collection:** `products` (the table)
- **Field:** `id`, `name`, `price`, `in_stock` (the columns)
- **Record:** Each row, e.g., `{ "id": "01H1...", "name": "Wireless Mouse", "price": "29.99", "in_stock": true }`

### What Moon Does NOT Do

Moon is intentionally minimal. It does **not** support:

- **Transactions:** No multi-statement atomicity; each request is independent.
- **Joins:** No SQL joins; model relationships in your application.
- **Triggers/Hooks:** No database-level triggers or event hooks.
- **Background Jobs:** No built-in job queue or async processing.
- **Foreign Keys:** Relations must be managed manually.
- **Migrations/Schema Versioning:** No built-in migration or schema versioning system.
- **Backup/Restore:** No built-in backup or restore; handle externally.
- **Fine-grained ACLs:** Only `user` and `admin` roles; no per-collection/field ACL.
- **WebSocket/Realtime:** No realtime or WebSocket support.
- **File/Binary Storage:** No file uploads or binary/blob storage.
- **Scheduled Tasks:** No cron or scheduled task support.
- **Encryption at Rest:** No built-in data encryption at rest.
- **Admin UI:** API-only; no built-in web UI or dashboard.
- **HTTP Methods:** Only supports `GET`, `POST`, and `OPTIONS` (no `PUT`, `PATCH`, or `DELETE`).
- **Public endpoints:** `/health`, `/` (alias for `/health`), `/doc`, `/doc/llms.md`, `/doc/llms.txt`, `/doc/llms.json`. The root path `GET /` is only available when no URL prefix is configured.
- No support for API versioning.
- No WebSocket/Realtime

### Design Constraints

- Collection names: lowercase, snake_case.
- Field names: unique per collection.
- No joins; handle relations at the application layer.

### Rules: Do's

- Moon is schema-on-demand.
- Always check or create collections before inserting data.
- Use API keys for server-side apps; JWT for user-facing auth.
- Endpoints follow AIP-136 custom actions (colon separator).
- Rate limits: JWT 100/min/user, API Key 1,000/min/key.
- User roles: `user` (limited), `admin` (full).
- Input validation: types and constraints enforced; always sanitize input.
- **Always use HTTPS in production.** (All curl examples assume HTTPS for production use.)
- Set explicit allowed origins for CORS.

### Rules: Don'ts

- Don’t use joins, transactions, triggers, or background jobs—handle these in your app.
- Don’t assume foreign keys; manage relations manually.

### Data Types

Supported column data types:

- **id**: Read-only ULID (128-bit, 26-character, URL-safe unique ID) generated by the server.
- **string**: Text values of any length (maps to TEXT in SQL).
- **integer**: 64-bit whole numbers.
- **decimal**: For decimal values. API input/output uses strings (e.g., "199.99"), default 2 decimal places.
- **boolean**: true/false values.
- **datetime**: Date/time in RFC3339 format (e.g., 2023-01-31T13:45:00Z).
- **json**: Arbitrary JSON object or array.

**_Note:_** Aggregation functions (sum, avg, min, max) are supported on both `integer` and `decimal` field types.

**Default Values by Type:**

- Default values are applied during collection creation if not explicitly provided.
- Defaults are assigned only to nullable fields.
- Non-nullable fields do not receive defaults and must always be included in API requests.

| Type       | Default Value         | Notes                             |
| ---------- | --------------------- | --------------------------------- |
| `string`   | `""` (empty string)   | Applied only if field is nullable |
| `integer`  | `0`                   | Applied only if field is nullable |
| `decimal`  | `"0.00"`              | Applied only if field is nullable |
| `boolean`  | `false`               | Applied only if field is nullable |
| `datetime` | `null`                | Applied for nullable fields       |
| `json`     | `"{}"` (empty object) | Applied only if field is nullable |

---

## Standard Response Pattern

### `:list` Endpoints

All List endpoints `GET /{resource}:list` return paginated collections of resources. All list endpoints share a consistent request/response pattern described in this section.

**Response Structure:**
Every list endpoint returns a JSON object with two top-level keys: `data` and `meta` similar to below reponse.

```json
{
  "data": [
    {
      "id": "01KHCZKMM0N808MKSHBNWF464F",
      "title": "Wireless Mouse",
      "price": "29.99"
    }
  ],
  "meta": {
    "count": 15,
    "limit": 15,
    "next": "01KHCZKMM0N808MKSHBNWF464F",
    "prev": "01KHCZFXAFJPS9SKSFKNBMHTP5",
    "total": 42
  }
}
```

- `data` - An array of resource objects. Each record always includes an `id` field (ULID), except collections which use `name` as the identifier.
- `meta` - Pagination metadata for the current page.
  - `count` (integer): Number of records returned in this response
  - `limit` (integer): The page size limit that was applied. Default is 15; maximum allowed is 200.
  - `next` (string | null): Cursor pointing to the last record on the current page. Pass to ?after to get the next page. null on the last page.
  - `prev` (string | null): Cursor pointing to the record before the current page. Pass to ?after to return to the previous page. null on the first page.
  - `total` (integer): Total number of records matching the current filters, regardless of pagination cursor.

The `:list` endpoint supports the following query parameters: `limit`, `after`, `sort`, `filter`, `q` (full-text search), and `fields` (field selection).

#### Pagination

For pagination use parameter `?after={cursor}` to return records after the specified ULID cursor. Omit this parameter to start from the first page.

This API uses cursor-based pagination. Each response includes `meta.next` and `meta.prev` cursors, both of which are used with the `?after` parameter.

```sh
# First page (no cursor needed)
GET /products:list

# Next page — use meta.next, meta.prev, or any valid record id from the previous response
GET /products:list?after=01KHCZKMM0N808MKSHBNWF464F
```

**Notes:**

- `meta.prev` is `null` on the first page and `meta.next` is `null` on the last page.
- Records are always returned in chronological order (by ULID/creation time).
- To page backwards: pass `?after={meta.prev}` from the current response. This returns the previous page of records (the record matching the cursor is excluded). Example: `GET /products:list?after=01KHCZFXAFJPS9SKSFKNBMHTP5`.
- For `?after={cursor}`, the cursor must always be a record's id (ULID). It can be:
  - A valid id of an existing record,
  - The value of `meta.prev` from the current response,
  - The value of `meta.next` from the current response.
- When `?after={cursor}` is used, only records that follow the specified id (ULID) are returned; the record matching the cursor is excluded from the results.
- If an invalid or non-existent cursor is provided, return an error response as specified in the [Standard Error Response](#standard-error-response)

### `:get` Endpoints

Get endpoints retrieve a single resource by its identifier `id` or `name`.

- `id` (string): ULID of the resource (required for users, API keys, and records)
- `name` (string): Name of the collection (required for collections)

**Important Notes:**

- **Single object**: The `data` field contains a single object (not an array).
- **No meta field**: Get endpoints don't need pagination metadata.
- **Consistent wrapper**: All `:get` endpoints use the `data` wrapper, matching `:list` endpoints.

### `:create` Endpoints

- **ID field**: The `id` field is system-generated and read-only. Do not include it in create requests.
- **Array format**: Collection records must always be sent as an array in `data`, even for single records.
- **Partial success**: If some records fail validation, successfully created records are returned in `data`.
- **Failed records**: Failed records are excluded from the `data` array. Check `meta.failed` count to detect partial failures, refer[Data Access](#data-access) section for details.
- **Status code**: Always returns `201 Created` if at least one record was created successfully.
- **Consistent wrapper**: All `:create` endpoints use the `data` field for created resource(s).
- **Message field**: Always includes a human-readable success message.
- **API Key security**: The `key` field appears in `data` only once during creation.
- **Error Response:** Follow [Standard Error Response](#standard-error-response) for any error handling

### `:destroy` Endpoints

**Parameters:**

- `id` (string): ULID of the resource (required for users, apikeys)
- `name` (string): Name of the collection (required for collections)
- `data` (array): Array of record IDs to delete (required for records)

**Important Notes:**

- **Array format**: Collection records must be sent as an array in `data`, even for single deletions.
- **Deleted IDs returned**: Response includes `data` array with IDs of successfully deleted records.
- **Partial success**: If some records fail to delete, the successfully deleted count is shown in `meta`.
- **Failed records**: Check `meta.failed` count to detect partial failures. Failed record IDs are excluded from the `data` array. refer[Data Access](#data-access) section for details.
- **Status code**: Returns `200 OK` if at least one record was deleted successfully.
- **Message field**: Always includes a human-readable success message.
- **Error Response:** Follow [Standard Error Response](#standard-error-response) for any error handling

### `:update` Endpoints

**Parameters:**

- `id` (string): ULID of the resource (required for users, apikeys)
- Request Body (object): Fields to update OR `action` parameter for special operations
- `action` (string): Special operation to perform (`reset_password`, `revoke_sessions`, `rotate`)
- `name` (string): Collection name (required for collection operations)
- `data` (array): Array with objects containing `id` plus fields to update (for records)

**Important Notes:**

- **Array format**: Collection records must be sent as an array in `data`, even for single updates.
- **Partial updates**: Only fields provided are updated; other fields remain unchanged.
- **Actions vs updates**: When `action` is specified, it takes precedence over field updates.
- **Action-specific fields**: Some actions require additional fields (e.g., `new_password` for `reset_password`).
- **Updated data returned**: Response includes the full updated resource(s) in `data`.
- **Partial success**: For batch updates, successfully updated records are returned in `data`.
- **Status code**: Returns `200 OK` if at least one record was updated successfully.
- **Key rotation**: `rotate` action returns the new key in `data.key` field (shown only once).
- **Warning field**: Optional field for security warnings (e.g., key rotation, password reset).
- **Error Response:** Follow [Standard Error Response](#standard-error-response) for any error handling

### `:schema` Endpoints

Retrieve the schema definition for a collection, including all fields, their types, constraints, and defaults.

`GET /{collection_name}:schema`

**Field Properties:**

- `name`: The field's name.
- `type`: The data type (`string`, `integer`, `decimal`, `boolean`, `timestamp`, etc., as defined in the specification).
- `nullable`: Indicates if the field can be omitted or set to `null` in API requests.
- `readonly`: Indicates if the field is system-generated and cannot be modified (e.g., `id`).
- `default`: The default value assigned when the field is not provided.
- `unique`: Specifies whether the field must have unique values (optional).

**Important Notes:**

- **System fields**: The `id` and `created_at` fields are automatically included in every collection and are readonly.
- **Total count**: Represents the total number of fields in the collection schema.
- **Schema introspection**: Use this endpoint to dynamically discover collection structure
- **Validation**: Schema information helps clients validate data before submission
- **Error Response:** Follow [Standard Error Response](#standard-error-response) for any error handling

---

## Standard Error Response

The API uses a simple, consistent error handling approach and strictly follows standard HTTP semantics.

- `200`: OK – Successful GET request |
- `201`: Created – Successful POST request creating resource |
- `400`: Invalid request (validation error, invalid parameter, malformed request)
- `401`: Authentication required
- `404`: Resource not found
- `429`: Too Many Requests
- `500`: Server error
- Only the codes listed above are permitted; do not use any others.

Note: `403` (Forbidden) is intentionally omitted in this specification to keep the error surface small. Authorization or permission failures should be handled via `401` per this document. If an implementation needs to distinguish "authenticated but not allowed" cases, add `403` and follow the same single-`message` JSON body pattern.

- Errors are indicated by standard HTTP status codes (for machines).
- Each error response includes only a single `message` field (for humans), intended for direct display to users.
- No internal error codes or additional error metadata are used.
- The HTTP status code is the only machine-readable error signal.
- Clients are not expected to parse or branch on error types.

When an error occurs, the API responds with the appropriate HTTP status code and a JSON body:

```json
{
  "message": "A human-readable description of the error"
}
```

See [Standard Error Response](./SPEC_API/090-errors.md) for any error handling

## Public Endpoints

Health and documentation endpoints are accessible without authentication. All other endpoints require authentication.

| Endpoint         | Method | Description                                                     |
| ---------------- | ------ | --------------------------------------------------------------- |
| `/`              | GET    | (alias for `/health`) |
| `/health`        | GET    | Health Endpoint (see [Health Endpoint](./SPEC_API/010-health.md)) |
| `/doc/`          | GET    | API Documentation (HTML)                                        |
| `/doc/llms.md`   | GET    | API Documentation (Markdown)                                    |
| `/doc/llms.txt`  | GET    | API Documentation (Plain Text, alias for `/doc/llms.md`)        |
| `/doc/llms.json` | GET    | API Documentation (JSON)                                        |

## Authentication

Except for [Public Endpoints](#public-endpoints), all other endpoints require authentication. To access protected endpoints, include the `Authorization: Bearer <TOKEN>` header in your requests

Supported authentication types:

- **JWT tokens** (`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) – for interactive users
- **API keys** (`moon_live_<64_chars>`) – for service integrations
- Both use the same `Authorization: Bearer` header format

**JWT Token Example :** JWT tokens are used for interactive users and are obtained from `POST /auth:login`:

**API Key Example :** API keys are used for service integrations and are obtained from `POST /apikeys:create`:

| Endpoint        | Method | Description                                |
| --------------- | ------ | ------------------------------------------ |
| `/auth:login`   | POST   | Authenticate user, receive tokens          |
| `/auth:logout`  | POST   | Invalidate current session's refresh token |
| `/auth:refresh` | POST   | Exchange refresh token for new tokens      |
| `/auth:me`      | GET    | Get current authenticated user info        |
| `/auth:me`      | POST   | Update current user's profile/password     |

### Important Notes

- **Token expiration**: Access tokens expire in 15 minutes by default (configurable via `jwt.access_expiry`). Use refresh token to obtain new access token without re-authentication.
- **Refresh token**: Single-use tokens. Each refresh returns a new access token AND a new refresh token. Store the new refresh token for subsequent refreshes.
- **Password change**: Changing password invalidates all existing sessions. User must login again with new credentials.
- **Authorization header**: Format is `Authorization: Bearer {access_token}`. Include this header in all authenticated requests.
- **Token storage**: Store tokens securely. Never expose tokens in URLs or logs.
- **Error Response:** Follow [Standard Error Response](#standard-error-response) for any error handling

See [Authentication API](./SPEC_API/020-auth.md).

---

## Manage User (Admin Only)

| Endpoint         | Method | Description                             |
| ---------------- | ------ | --------------------------------------- |
| `/users:list`    | GET    | List all users                          |
| `/users:get`     | GET    | Get specific user by ID                 |
| `/users:create`  | POST   | Create new user                         |
| `/users:update`  | POST   | Update user properties or admin actions |
| `/users:destroy` | POST   | Delete user account                     |

See [Users API](./SPEC_API/030-users.md). All error handling must follow [Standard Error Response](#standard-error-response)

## Manage API Keys (Admin Only)

| Endpoint           | Method | Description                           |
| ------------------ | ------ | ------------------------------------- |
| `/apikeys:list`    | GET    | List all API keys                     |
| `/apikeys:get`     | GET    | Get specific API key                  |
| `/apikeys:create`  | POST   | Create new API key                    |
| `/apikeys:update`  | POST   | Update API key metadata or rotate key |
| `/apikeys:destroy` | POST   | Delete API key                        |

See [APIKeys API](./SPEC_API/040-apikeys.md). All error handling must follow [Standard Error Response](#standard-error-response)

## Manage Collections

These endpoints manage database tables (collections) and their schemas.

| Endpoint               | Method | Description                                  |
| ---------------------- | ------ | -------------------------------------------- |
| `/collections:list`    | GET    | List all collections                         |
| `/collections:get`     | GET    | Get collection schema (requires `?name=...`) |
| `/collections:create`  | POST   | Create a new collection                      |
| `/collections:update`  | POST   | Update collection schema                     |
| `/collections:destroy` | POST   | Delete a collection                          |

Update collection support following schema modification operations:

- `add_columns` - Add new columns
- `rename_columns` - Rename existing columns
- `modify_columns` - Change column types or attributes
- `remove_columns` - Remove existing columns

See [Collection Managment API](./SPEC_API/050-collection.md). All error handling must follow [Standard Error Response](#standard-error-response)

## Data Access

These endpoints manage records within a specific collection. Replace `{collection_name}` with your collection name.

| Endpoint                     | Method | Description                              |
| ---------------------------- | ------ | ---------------------------------------- |
| `/{collection_name}:list`    | GET    | List all records                         |
| `/{collection_name}:schema`  | GET    | Get collection schema (read-only)        |
| `/{collection_name}:get`     | GET    | Get a single record (requires `?id=...`) |
| `/{collection_name}:create`  | POST   | Create a new record                      |
| `/{collection_name}:update`  | POST   | Update an existing record                |
| `/{collection_name}:destroy` | POST   | Delete a record                          |

See [Data Access API](./SPEC_API/060-data.md). All error handling must follow [Standard Error Response](#standard-error-response)

### Query Options

Query parameters for filtering, sorting, searching, field selection, and pagination when listing records. Using these options allows you to retrieve specific subsets of data based on your criteria.

| Query Options             | Description                                                |
| ------------------------- | ---------------------------------------------------------- |
| `?column[operator]=value` | Filter records by column values using comparison operators |
| `?sort={fields}`          | Sort by one or more fields (prefix `-` for descending)     |
| `?q={term}`               | Full-text search across all text columns                   |
| `?fields={field1,field2}` | Select specific fields to return (id always included)      |
| `?limit={number}`         | Limit number of records returned (default: 15, max: 200)   |
| `?after={cursor}`         | Get records after the specified cursor                     |

See [Data Access API > Query Options](./SPEC_API/070-query.md). All error handling must follow [Standard Error Response](#standard-error-response)

#### Combined Examples

All query parameters can be combined in a single request.

```sh
# Filter by price range, sort descending, limit results
GET /products:list?quantity[gte]=10&price[lt]=100&sort=-price&limit=5

# Full-text search with a brand filter, returning only select fields
GET /products:list?q=laptop&brand[eq]=Wow&fields=title,price,quantity

# Multi-filter with pagination
GET /products:list?price[gte]=100&quantity[gt]=0&sort=-price&limit=10&after=01KHCZKMM0N808MKSHBNWF464F
```

### Aggregation Operations

Moon provides dedicated aggregation endpoints that perform calculations directly on the server. This enables fast, efficient analytics—such as counting records, summing numeric fields, computing averages, and finding minimum or maximum values—without transferring unnecessary data.

Server-side aggregation endpoints for analytics. Replace `{collection_name}` with your collection name.

| Endpoint                   | Method | Description                                   |
| -------------------------- | ------ | --------------------------------------------- |
| `/{collection_name}:count` | GET    | Count records                                 |
| `/{collection_name}:sum`   | GET    | Sum numeric field (requires `?field=...`)     |
| `/{collection_name}:avg`   | GET    | Average numeric field (requires `?field=...`) |
| `/{collection_name}:min`   | GET    | Minimum value (requires `?field=...`)         |
| `/{collection_name}:max`   | GET    | Maximum value (requires `?field=...`)         |

See [Data Access API > Aggregation Operations](./SPEC_API/080-aggregation.md). All error handling must follow [Standard Error Response](#standard-error-response)

**Note:**

- Replace `{collection_name}` with your collection name.
- Aggregation can be combined with filters (e.g., `?quantity[gt]=10`) to perform calculations on specific subsets of data.
- Aggregation functions (`sum`, `avg`, `min`, `max`) are supported only on `integer` and `decimal` field types.
- Combine aggregation with query filters for calculations on specific subsets:
  - `/products:count?quantity[gt]=10`
  - `/products:sum?field=quantity&brand[eq]=Wow`
  - `/products:max?field=quantity`

## Security

### Request Correlation (`X-Request-ID`)

Moon supports request correlation using the `X-Request-ID` header.

**Lifecycle:**

1. **Client sends (optional):** Clients may include `X-Request-ID` in the request.
2. **Server resolves ID:**
  - If `X-Request-ID` is provided, Moon uses that value.
  - If not provided, Moon generates a request ID.
3. **Server returns ID:** Moon sets `X-Request-ID` on the response so clients can correlate request/response pairs.
4. **Logs include ID:** The same value is written to logs as `request_id` for tracing and debugging.

**Operational Notes:**

- Use `X-Request-ID` when reporting errors to support teams.
- For failed requests (4xx/5xx), use the response `X-Request-ID` to locate related server logs.
- In browser clients, this header can be read when CORS exposes `X-Request-ID`.

### Rate Limiting

Each response includes these headers to help you track your usage:

- `X-RateLimit-Limit`: Maximum requests allowed per time window
- `X-RateLimit-Remaining`: Requests left in the current window
- `X-RateLimit-Reset`: Unix timestamp when your quota resets

**Example Response Headers:**

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1706875200
```

**If You Exceed the Limit (429 Too Many Requests):**

When you go over your limit (100/min/user for JWT, 1000/min/key for API Key), you’ll get:

```json
{
  "message": "rate limit exceeded"
}
```

**Response Headers:**

```text
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 60
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1706875260
```

Wait until the time in `X-RateLimit-Reset` or use the `Retry-After` value (in seconds) before making more requests.

---

### CORS Configuration

Moon supports Cross-Origin Resource Sharing (CORS) for browser clients with flexible, pattern-based configuration.

**Public Endpoints (No Auth):**

Refer [Public Endpoints](./010-public.md)

**Default CORS Headers:**

```text
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Authorization, Content-Type
Access-Control-Max-Age: 3600
```

- CORS can be set per endpoint or pattern in config.
- Admins can register CORS-enabled endpoints and restrict origins.
- Public endpoints can bypass authentication.
- See `SPEC.md` for full config details.

**OPTIONS Preflight Example:**

```bash
curl -X OPTIONS "http://localhost:6006/collections:list" \
  -H "Origin: http://localhost:3000" \
  -H "Access-Control-Request-Method: GET"
```

**Sample Response:**

```json
{
  "allowed_methods": ["GET", "POST", "OPTIONS"],
  "allowed_headers": ["Authorization", "Content-Type"],
  "max_age": 3600
}
```

**Sample Response Headers:**

```text
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Authorization, Content-Type
Access-Control-Max-Age: 3600
```

- **TIP:** In production server set a specific allowed origin (not `*`).
