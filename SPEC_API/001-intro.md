Moon enables rapid, migrationless management of database tables and records through a dynamic RESTful API.

### Moon Terminology

Moon stores data in the format: Collection, Field, and Record.

In database terminology, these are Tables, Columns, and Rows, respectively.

For example, consider the table `products` below.

```md
| id        | name           | price   | in_stock |
|-----------|----------------|---------|----------|
| 01H1...   | Wireless Mouse | 29.99   | true     |
| 01H2...   | USB Keyboard   | 19.99   | false    |
```

- **Collection:** `products` (the table)
- **Field:** `id`, `name`, `price`, `in_stock` (the columns)
- **Record:** Each row, e.g., `{ "id": "01H1...", "name": "Wireless Mouse", "price": "29.99", "in_stock": true }`

### What Moon Does NOT Do

Moon is intentionally minimal. It does **not** support:

- **Transactions:** No multi-statement atomicity; each request is independent.
- **Joins:** No SQL joins; model relationships in your application.
- **Triggers/Hooks:** No database-level triggers or event hooks.
- **Background Jobs:** No built-in job queue or async processing.
- **Foreign Keys:** Relations must be managed manually.
- **Migrations/Schema Versioning:** No built-in migration or schema versioning system.
- **Backup/Restore:** No built-in backup or restore; handle externally.
- **Fine-grained ACLs:** Only `user` and `admin` roles; no per-collection/field ACL.
- **WebSocket/Realtime:** No realtime or WebSocket support.
- **File/Binary Storage:** No file uploads or binary/blob storage.
- **Scheduled Tasks:** No cron or scheduled task support.
- **Encryption at Rest:** No built-in data encryption at rest.
- **Admin UI:** API-only; no built-in web UI or dashboard.
- **HTTP Methods:** Only supports `GET`, `POST`, and `OPTIONS` (no `PUT`, `PATCH`, or `DELETE`).
- **Public endpoints:** `/health`, `/doc`, `/doc/llms.md`, `/doc/llms.txt`, `/doc/llms.json`.

### Design Constraints

- Collection names: lowercase, snake_case.
- Field names: unique per collection.
- No joins; handle relations at the application layer.

### Rules: Do's

- Moon is schema-on-demand.
- Always check or create collections before inserting data.
- Use API keys for server-side apps; JWT for user-facing auth.
- Endpoints follow AIP-136 custom actions (colon separator).
- Rate limits: JWT 100/min/user, API Key 1,000/min/key.
- User roles: `user` (limited), `admin` (full).
- Input validation: types and constraints enforced; always sanitize input.
- **Always use HTTPS in production.** (All curl examples assume HTTPS for production use.)
- Set explicit allowed origins for CORS.

### Rules: Don'ts

- Don’t use joins, transactions, triggers, or background jobs—handle these in your app.
- Don’t assume foreign keys; manage relations manually.

### Data Types

Supported column data types:

| Type        | Description |
|-------------|-------------|
| `id`        | Read-only ULID (128-bit, 26-character, URL-safe unique ID) generated by the server. |
| `string`    | Text values of any length (maps to TEXT in SQL) |
| `integer`   | 64-bit whole numbers |
| `decimal`   | For decimal values. API input/output uses strings (e.g., `"199.99"`), default 2 decimal places |
| `boolean`   | true/false values |
| `datetime`  | Date/time in RFC3339 or ISO 8601 format (e.g., 2023-01-31T13:45:00Z) |
| `json`      | Arbitrary JSON object or array |

***Note:*** Aggregation functions (sum, avg, min, max) are supported on both `integer` and `decimal` field types.

**Default Values by Type** 

- Default values are applied during collection creation if not explicitly provided.
- Defaults are assigned only to nullable fields.
- Non-nullable fields do not receive defaults and must always be included in API requests.

| Type | Default Value | Notes |
|------|--------------|-------|
| `string` | `""` (empty string) | Applied only if field is nullable |
| `integer` | `0` | Applied only if field is nullable |
| `decimal` | `"0.00"` | Applied only if field is nullable |
| `boolean` | `false` | Applied only if field is nullable |
| `datetime` | `null` | Applied for nullable fields |
| `json` | `"{}"` (empty object) | Applied only if field is nullable |

### Authentication

Except for documentation and health endpoints, all other endpoints require authentication. To access protected endpoints, include the ```Authorization: Bearer <TOKEN>``` header in your requests

Supported authentication types:

- **JWT tokens** (`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) – for interactive users
- **API keys** (`moon_live_<64_chars>`) – for service integrations
- Both use the same `Authorization: Bearer` header format

**JWT Token Example :** JWT tokens are used for interactive users and are obtained from `POST /auth:login`:

```bash
# Login and save tokens to environment variables
response=$(curl -s -X POST "http://localhost:6006/auth:login" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"moonadmin12#"}')
ACCESS_TOKEN=$(echo $response | jq -r '.access_token')
REFRESH_TOKEN=$(echo $response | jq -r '.refresh_token')

# Use in subsequent requests
curl -s "http://localhost:6006/collections:list" \
  -H "Authorization: Bearer $ACCESS_TOKEN" | jq .
```

**API Key Example :** API keys are used for service integrations and are obtained from `POST /apikeys:create`:

```bash
# Create an API key (requires admin role)
curl -X POST "http://localhost:6006/apikeys:create" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"My Service Key","role":"user"}' | jq .

# Use the API key in requests (same Authorization header format)
curl -s "http://localhost:6006/collections:list" \
  -H "Authorization: Bearer moon_live_abc123..." | jq .
```

### Standard Response Pattern for `:list` Endpoints

List endpoints return paginated collections of resources. All list endpoints share a consistent request/response pattern described in this section.

**Applicable Endpoints:**

- List Users: `GET /users:list`
- List API Keys: `GET /apikeys:list`
- List Collections: `GET /collections:list`
- List Collection Records: `GET /{collection_name}:list`

**Response Structure:**
Every list endpoint returns a JSON object with two top-level keys: `data` and `meta` similar to below reponse.

```json
{
  "data": [
    {
      "id": "01KHCZKMM0N808MKSHBNWF464F",
      "title": "Wireless Mouse",
      "price": "29.99"
    }
  ],
  "meta": {
    "count": 15,
    "limit": 15,
    "next": "01KHCZKMM0N808MKSHBNWF464F",
    "prev": "01KHCZFXAFJPS9SKSFKNBMHTP5"
  }
}
```

- `data` - An array of resource objects. Each record always includes an `id` field (ULID), except collections which use `name` as the identifier.
- `meta` - Pagination metadata for the current page.
  - `count` (integer): Number of records returned in this response
  - `limit` (integer): The page size limit that was applied. Default is 15; maximum allowed is 100.
  - `next` (string | null): Cursor pointing to the last record on the current page. Pass to ?after to get the next page. null on the last page.
  - `prev` (string | null): Cursor pointing to the record before the current page. Pass to ?after to return to the previous page. null on the first page.

---

The `:list` endpoint supports the following query parameters: `limit`, `after`, `sort`, `filter`, `q` (full-text search), and `fields` (field selection).

### Pagination

For pagination use parameter `?after={cursor}` to return records after the specified ULID cursor. Omit this parameter to start from the first page.

This API uses cursor-based pagination. Each response includes `meta.next` and `meta.prev` cursors, both of which are used with the `?after` parameter.

```sh
# First page (no cursor needed)
GET /products:list

# Next page — use meta.next, meta.prev, or any valid record id from the previous response
GET /products:list?after=01KHCZKMM0N808MKSHBNWF464F
```

**Notes:**

- `meta.prev` is `null` on the first page and `meta.next` is `null` on the last page.
- Records are always returned in chronological order (by ULID/creation time).
 - To page backwards: pass `?after={meta.prev}` from the current response. This returns the previous page of records (the record matching the cursor is excluded). Example: `GET /products:list?after=01KHCZFXAFJPS9SKSFKNBMHTP5`.
- For `?after={cursor}`, the cursor must always be a record's id (ULID). It can be:
  - A valid id of an existing record,
  - The value of `meta.prev` from the current response,
  - The value of `meta.next` from the current response.
- When `?after={cursor}` is used, only records that follow the specified id (ULID) are returned; the record matching the cursor is excluded from the results.
- If an invalid or non-existent cursor is provided, return an error response as specified in the [Standard Error Response](./090-error.md).